/*=======================================================================
 * Project: Mediatex
 * Module : shell scanner

 * shell scanner

 MediaTex is an Electronic Records Management System
 Copyright (C) 2014 2015 2016 2017 Nicolas Roche
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 =======================================================================*/

%top {
/*=======================================================================
 * Version: this file is generated by LEX using shellQuery.l
 * Project: Mediatex
 * Module : shell scanner

 * shell scanner

 MediaTex is an Electronic Records Management System
 Copyright (C) 2014 2015 2016 2017 Nicolas Roche
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
=======================================================================*/

#include "mediatex-types.h" // needed for off_t set on 64 bits
}
   
%{
#include "mediatex-config.h"
#include "client/mediatex-client.h"
#include "parser/shellQuery.tab.h"
%}

/* definitions: ====================================================*/

/* Options for Specifing Filenames: */
%option outfile="parser/shellQuery.c"
%option header-file="parser/shellQuery.h"

/* Options Affecting Scanner Behavior: */
%option case-insensitive
%option nolex-compat
/* option batch OU interactive */
%option batch
%option 8bit
%option noposix-compat
%option nostdinit
%option noyywrap
   
/* Code-Level And API Options: */
%option ansi-definitions
%option ansi-prototypes
%option reentrant 
%option bison-bridge
%option noc++
%option pointer
%option prefix="shell_"
%option nomain
%option unistd

/* Options for Scanner Speed and Size: */
%option noalign
%option ecs
%option nometa-ecs
%option noread

/* Debugging Options: */
%option nobackup
%option debug
%option noperf-report
%option warn

/* Miscellaneous Options: */
%option nounput
%option noinput

 /* scaner states */
%x COMMENT
%x USERVALUE
%x COLLECTION

%%
   /* rules: ==========================================================*/

 /* first rule: */
<INITIAL>{

	^#.*$         /* : eat up comments */
	\/\/.*$       /* : eat up comments */

	\/\* {
	  BEGIN(COMMENT);
	}

	(\n|\r\n) {
	  return(shellEOL);
	}

	/* objects */

	coll(ection)? {
	  BEGIN(COLLECTION);
	  return(shellCOLL);
	}

	supp(ort)? {
	  BEGIN(USERVALUE);
	  return(shellSUPP);
	}

	key {
	  BEGIN(USERVALUE);
	  return(shellKEY);
	}

	user {
	  BEGIN(USERVALUE);
	  return(shellUSER);
	}

	file {
	  BEGIN(USERVALUE);
	  return(shellFILE);
	}

	cat|cata|catalog {
	  BEGIN(USERVALUE);
	  return(shellCATALOG);
	}

	extr|rules|extractrules {
	  BEGIN(USERVALUE);
	  return(shellRULES);
	}

	/* prefixs */

	adm(in)? {
	  return(shellADMIN);
	}

	(srv|serv|server) {
	  return(shellSERVER);
	}

	master {
	  return(shellMASTER);
	}

	/* locutions */

	all {
	  return(shellALL);
	}

	to {
	  return(shellTO);
	}

	from {
	  return(shellFROM);
	}

	as {
	  BEGIN(USERVALUE);
	  return(shellAS);
	}

	for {
	  BEGIN(USERVALUE);
	  return(shellFOR);
	}

	on {
	  BEGIN(USERVALUE);
	  return(shellON);
	}

	/* orders */

	get {
	  BEGIN(USERVALUE);
	  return(shellGET);
	}

	bind {
	  return(shellBIND);
	}

	unbind {
	  return(shellUNBIND);
	}

	mount {
	  BEGIN(USERVALUE);
	  return(shellMOUNT);
	}

	umount {
	  BEGIN(USERVALUE);
	  return(shellUMOUNT);
	}

	init(ialize)? {
	  return(shellINIT);
	}

	remove {
	  return(shellREMOVE);
	}

	purge {
	  return(shellPURGE);
	}

	clean {
	  return(shellCLEAN);
	}

	add {
	  return(shellADD);
	}

	del(ete)? {
	  return(shellDEL);
	}

	note {
	  return(shellNOTE);
	}

	l(s|ist) {
	  return(shellLIST);
	}

	update {
	  return(shellUPDATE);
	}

	commit {
	  return(shellCOMMIT);
	}

	make {
	  return(shellMAKE);
	}

	up(grade)? {
	  return(shellUPGRADE);
	}

	up(grade)?\+ {
	  return(shellUPGRADEP);
	}

	upload {
	  return(shellUPLOAD);
	}

	upload\+ {
	  return(shellUPLOADP);
	}

	upload\+\+ {
	  return(shellUPLOADPP);
	}

	check {
	  return(shellCHECK);
	}

	su {
	  return(shellSU);
	}

	motd {
	  return(shellMOTD);
	}

	audit {
	  return(shellAUDIT);
	}

	save {
	  return(shellSAVE);
	}

	extract {
	  return(shellEXTRACT);
	}

	notify {
	  return(shellNOTIFY);
	}

	quick {
	  return(shellQUICK);
	}

	scan {
	  return(shellSCAN);
	}

	trim {
	  return(shellTRIM);
	}

	status {
	  return(shellSTATUS);
	}

	@ {
	  BEGIN(COLLECTION);
	  return(shellAROBASE);
	}

	- {
	  BEGIN(COLLECTION);
	  return(shellMINUS);
	}
	
	: {
	  BEGIN(USERVALUE);
	  return(shellCOLON);
	}
 }

<USERVALUE>{

  (\n|\r\n) {
    BEGIN(INITIAL);
    return(shellEOL);
  }

  [+-]?[[:digit:]]+ {
    BEGIN(INITIAL);
    sscanf(yytext, "%i", &yylval->number);
    return(shellNUMBER);
  }

  [^\n[:blank:]]* {
    BEGIN(INITIAL);
    strcpy(yylval->string, yytext);
    return(shellSTRING);
  }
 }

<COLLECTION>{

  (\n|\r\n) {
    BEGIN(INITIAL);
    return(shellEOL);
  }

  [^\n[:blank:]:\-@]* {
    BEGIN(INITIAL);
    strcpy(yylval->string, yytext);
    return(shellSTRING);
  }
 }

<COMMENT>{
  [^\n\r]   /* : eat up any unmatched character */
    
  \*\/ {
    BEGIN(INITIAL);
  }
}

<*>{

  [[:blank:]]+  /* : eat up any blank character */

  . {  /* : eat up any unmatched character and 
	  let bison manage the errors */
    logParser(LOG_WARNING, "scanner read unexpected caractere '%s'", 
	    yytext);
    return(shellERROR);
  }
}

%%
   /* user code (literally copied to the generated source) :
      ==========*/


/*=======================================================================
 * Function   : getCommandLine
 * Description: scan the command line (without options)
 * Synopsis   : void getCommandLine(int argc, char** argv, int optind)
 * Input      : int argc, char** argv, int optind
 * Output     : set the commandLine global variable
 * Note       : remind to protect \" in cmdline
=======================================================================*/
void getCommandLine(int argc, char** argv, int optind)
{
  int i = 0;
  int lenght = 0;
  char* ptr = env.commandLine;

  logParser(LOG_DEBUG, "%s", "getCommandLine"); 
  for (i=optind; i<argc; ++i) {
    lenght = strlen(argv[i]);
    strcpy(ptr, argv[i]);
    ptr += lenght;
    *(ptr++) = ' ';
  }
  *(ptr) = (char)0;
  logParser(LOG_DEBUG, "command line: %s", 
	    (ptr == env.commandLine)?"(empty)":env.commandLine);
  *(--ptr) = '\n';
} 

/* Local Variables: */
/* mode: c */
/* mode: font-lock */
/* mode: auto-fill */
/* End: */
