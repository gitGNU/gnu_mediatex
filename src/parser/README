
If it can help...


  //////////////
 // server.l //
//////////////
typedef struct ServExtra {
  int            lineNo;
} ServExtra;

// %union{} used by flex/bison to write/read values
// (only available when linked with bison)
typedef union ServBisonUnion {
  // C types -   lex token types
  off_t          number;
  off_t          size;
  time_t         time;
  float          score;
  char*          string;
  char           hash[MAX_SIZE_HASH+1];

  // C types -   bison token types
  struct Server* server_t;
  struct Image*  image_t;
  struct RG*     imagesRing;
} ServBisonUnion;
#define YYSTYPE ServBisonUnion
%%

((ServExtra*)yyextra)->lineNo);
yytext
yyleng
yylval->number
yylval->size
yylval->time
yylval->score
yylval->string
yylval->hash


  //////////////
 // server.h //
//////////////
#define yyin yyg->yyin_r
#define yyout yyg->yyout_r
#define yyextra yyg->yyextra_r
#define yyleng yyg->yyleng_r
#define yytext yyg->yytext_r
#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)
#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)
#define yy_flex_debug yyg->yy_flex_debug_r

YY_EXTRA_TYPE serv_get_extra (yyscan_t yyscanner );
YYSTYPE * serv_get_lval (yyscan_t yyscanner );

  //////////////
 // server.c //
//////////////
/* Holds the entire state of the reentrant scanner. */
struct yyguts_t
    {

    /* User-defined. Not touched by flex. */
    YY_EXTRA_TYPE yyextra_r;

    /* The rest are the same as the globals declared in the non-reentrant scanner. */
    FILE *yyin_r, *yyout_r;
 ...
    int yyleng_r;
 ...
    char *yytext_r;
 ...
    YYSTYPE * yylval_r;

    }; /* end struct yyguts_t */

YY_EXTRA_TYPE serv_get_extra  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yyextra;
}

YYSTYPE * serv_get_lval  (yyscan_t yyscanner)
{
    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
    return yylval;
}

  //////////////
 // server.y //
//////////////
void serv_error(const char* message);

// scanner + anything we may want
// (parameter type of reentrant 'yyparse' function)
typedef struct ServBisonSelf {
  yyscan_t    scanner;
  // ... anything we want here
  Collection* collection;
  Server*     currentServer;
} ServBisonSelf;

// name of the belows parameter into bison: must use a common name
// define YYLEX yylex (&yylval, YYLEX_PARAM)
#define YYPARSE_PARAM servBisonSelf
#define YYLEX_PARAM   ((ServBisonSelf*)servBisonSelf)->scanner

// shortcut maccros
#define SERV_LINE_NO ((ServExtra*)serv_get_extra(YYLEX_PARAM))->lineNo
#define SERV_COLL    ((ServBisonSelf*)servBisonSelf)->collection
#define SERV_CURRSRV ((ServBisonSelf*)servBisonSelf)->currentServer

%%
%token <string>   srvSTRING
%token <number>   srvNUMBER
%token <score>    srvSCORE
%token <hash>     srvHASH
%token <string>   srvERROR
%token <size>     srvSIZE
%token <time>     srvTIME
%%

  logParser(LOG_DEBUG, "line %-3i new server: %s", SERV_LINE_NO, $1);
%%
 ServBisonSelf parser;
 ServExtra extra;
 serv_lex_init(&parser.scanner);
 serv_set_extra (&extra, parser.scanner);
 ((ServExtra*)serv_get_extra(parser.scanner))->lineNo);
 logEmit(LOG_ERR, "servers.txt file parser error on line %i",
    ((ServExtra*)serv_get_extra(parser.scanner))->lineNo);
