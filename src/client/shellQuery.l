/*=======================================================================
 * Version: $Id: shellQuery.l,v 1.1 2014/10/13 19:38:49 nroche Exp $
 * Project: Mediatex
 * Module : shell scanner

 * shell reentrant scanner

 MediaTex is an Electronic Records Management System
 Copyright (C) 2014  Nicolas Roche
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 =======================================================================*/

/* definitions: ====================================================*/

/* Options for Specifing Filenames: */
%option outfile="shellQuery.c"
%option header-file="shellQuery.h"

/* Options Affecting Scanner Behavior: */
%option case-insensitive
%option nolex-compat
/* option batch OU interactive */
%option batch
%option 8bit
%option noposix-compat
%option nostdinit
%option noyywrap

/* Code-Level And API Options: */
%option ansi-definitions
%option ansi-prototypes
%option reentrant 
%option bison-bridge
%option noc++
%option pointer
%option prefix="shellQuery_"
%option nomain
%option unistd

/* Options for Scanner Speed and Size: */
%option noalign
%option ecs
%option nometa-ecs
%option noread

/* Debugging Options: */
%option nobackup
%option debug
%option noperf-report
%option warn

/* Miscellaneous Options: */
%option nounput

%top {
/*=======================================================================
 * Version: this file is generated by LEX using shellQuery.l
 * Project: Mediatex
 * Module : shell scanner

 * shell reentrant scanner

 MediaTex is an Electronic Records Management System
 Copyright (C) 2014  Nicolas Roche
 
 This program is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.
 
 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
=======================================================================*/

#include "../mediatex.h"
#include "../misc/log.h"
#include "../memory/strdsm.h"
#include "../memory/confTree.h"
#include "../memory/supportTree.h"

#ifndef utMAIN 
#include "shellQuery.tab.h"
#endif

   extern int shellQueryLocalCounter;
   extern int shellQuery_input_file; /* to deal with files (not streams) */
   int getCommandLine(int argc, char** argv, int optind);

   // %union{} used by flex/bison to write/read values
   typedef union BisonUnion {
     int   number;
     char string[MAX_SIZE_STRING+1];
     Collection* coll;
   } BisonUnion;

#define YYSTYPE BisonUnion
#define YY_NO_INPUT // no warning
}

%{
  int shellQueryLocalCounter = 1;
  int shellQuery_input_file = 0;
  int number = 0;

  /* add to deal with buffer */
#define YY_INPUT(buf,result,max_size)					\
  {									\
    if (env.commandLine[0] != (char)0){					\
      strncpy(buf, env.commandLine, max_size);				\
      result = strlen(buf);						\
      env.commandLine[0] = (char)0;					\
    } else result = YY_NULL;						\
  }
%}

 /* scaner states */
%x COMMENT
%x USERVALUE
%x COLLECTION

%%
   /* rules: ==========================================================*/

%{
    /* local variables: */
%}

 /* first rule: */

<INITIAL>{

	^#.*$         /* : eat up comments */
	\/\/.*$       /* : eat up comments */

	\/\* {
	  BEGIN(COMMENT);
	}

	(\n|\r\n) {
	  ++shellQueryLocalCounter;
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "EOL");
#else	/*	: utMAIN	*/
	  return(shellEOL);
#endif	/*	: utMAIN	*/
	}

	/* objects */

	coll(ection)? {
	  BEGIN(COLLECTION);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "COLLECTION");
#else	/*	: utMAIN	*/
	  return(shellCOLL);
#endif	/*	: utMAIN	*/
	}

	supp(ort)? {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "SUPPORT");
#else	/*	: utMAIN	*/
	  return(shellSUPP);
#endif	/*	: utMAIN	*/
	}

	key {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "KEY");
#else	/*	: utMAIN	*/
	  return(shellKEY);
#endif	/*	: utMAIN	*/
	}

	user {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "USER");
#else	/*	: utMAIN	*/
	  return(shellUSER);
#endif	/*	: utMAIN	*/
	}

	bind {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "BIND");
#else	/*	: utMAIN	*/
	  return(shellBIND);
#endif	/*	: utMAIN	*/
	}

	unbind {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "UNBIND");
#else	/*	: utMAIN	*/
	  return(shellUNBIND);
#endif	/*	: utMAIN	*/
	}

	mount {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "MOUNT");
#else	/*	: utMAIN	*/
	  return(shellMOUNT);
#endif	/*	: utMAIN	*/
	}

	umount {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "UMOUNT");
#else	/*	: utMAIN	*/
	  return(shellUMOUNT);
#endif	/*	: utMAIN	*/
	}

	upload {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "UPLOAD");
#else	/*	: utMAIN	*/
	  return(shellUPLOAD);
#endif	/*	: utMAIN	*/
	}

	get {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "GET");
#else	/*	: utMAIN	*/
	  return(shellGET);
#endif	/*	: utMAIN	*/
	}

	/* prefixs */

	adm(in)? {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "ADMIN");
#else	/*	: utMAIN	*/
	  return(shellADMIN);
#endif	/*	: utMAIN	*/
	}

	(srv|serv|server) {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "SERVER");
#else	/*	: utMAIN	*/
	  return(shellSERVER);
#endif	/*	: utMAIN	*/
	}

	/* locutions */

	all {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "ALL");
#else	/*	: utMAIN	*/
	  return(shellALL);
#endif	/*	: utMAIN	*/
	}

	to {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "TO");
#else	/*	: utMAIN	*/
	  return(shellTO);
#endif	/*	: utMAIN	*/
	}

	from {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "FROM");
#else	/*	: utMAIN	*/
	  return(shellFROM);
#endif	/*	: utMAIN	*/
	}

	as {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "AS");
#else	/*	: utMAIN	*/
	  return(shellAS);
#endif	/*	: utMAIN	*/
	}

	on {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "ON");
#else	/*	: utMAIN	*/
	  return(shellON);
#endif	/*	: utMAIN	*/
	}

	/* conf orders */

	init(ialize)? {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "INIT");
#else	/*	: utMAIN	*/
	  return(shellINIT);
#endif	/*	: utMAIN	*/
	}

	remove {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "REMOVE");
#else	/*	: utMAIN	*/
	  return(shellREMOVE);
#endif	/*	: utMAIN	*/
	}

	purge {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "PURGE");
#else	/*	: utMAIN	*/
	  return(shellPURGE);
#endif	/*	: utMAIN	*/
	}

	clean {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "PURGE");
#else	/*	: utMAIN	*/
	  return(shellCLEAN);
#endif	/*	: utMAIN	*/
	}

	add {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "ADD");
#else	/*	: utMAIN	*/
	  return(shellADD);
#endif	/*	: utMAIN	*/
	}

	del(ete)? {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "DEL");
#else	/*	: utMAIN	*/
	  return(shellDEL);
#endif	/*	: utMAIN	*/
	}

	note {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "NOTE");
#else	/*	: utMAIN	*/
	  return(shellNOTE);
#endif	/*	: utMAIN	*/
	}

	l(s|ist) {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "LIST");
#else	/*	: utMAIN	*/
	  return(shellLIST);
#endif	/*	: utMAIN	*/
	}

	update? {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "UPDATE");
#else	/*	: utMAIN	*/
	  return(shellUPDATE);
#endif	/*	: utMAIN	*/
	}

	up(grade)? {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "UPGRADE");
#else	/*	: utMAIN	*/
	  return(shellUPGRADE);
#endif	/*	: utMAIN	*/
	}

	commit {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "COMMIT");
#else	/*	: utMAIN	*/
	  return(shellCOMMIT);
#endif	/*	: utMAIN	*/
	}

	make {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "MAKE");
#else	/*	: utMAIN	*/
	  return(shellMAKE);
#endif	/*	: utMAIN	*/
	}

	check {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "CHECK");
#else	/*	: utMAIN	*/
	  return(shellCHECK);
#endif	/*	: utMAIN	*/
	}

	su {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "SU");
#else	/*	: utMAIN	*/
	  return(shellSU);
#endif	/*	: utMAIN	*/
	}

	motd {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "MOTD");
#else	/*	: utMAIN	*/
	  return(shellMOTD);
#endif	/*	: utMAIN	*/
	}

	save {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "SAVE");
#else	/*	: utMAIN	*/
	  return(shellSAVE);
#endif	/*	: utMAIN	*/
	}

	extract {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "EXTRACT");
#else	/*	: utMAIN	*/
	  return(shellEXTRACT);
#endif	/*	: utMAIN	*/
	}

	notify {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "NOTIFY");
#else	/*	: utMAIN	*/
	  return(shellNOTIFY);
#endif	/*	: utMAIN	*/
	}

	deliver {
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "DELIVER");
#else	/*	: utMAIN	*/
	  return(shellDELIVER);
#endif	/*	: utMAIN	*/
	}

	@ {
	  BEGIN(COLLECTION);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "AROBASE");
#else	/*	: utMAIN	*/
	  return(shellAROBASE);
#endif	/*	: utMAIN	*/
	}

	- {
	  BEGIN(COLLECTION);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "%s", "MINUS");
#else	/*	: utMAIN	*/
	  return(shellMINUS);
#endif	/*	: utMAIN	*/
	}
	
	: {
	  BEGIN(USERVALUE);
#ifdef utMAIN
	  logEmit(LOG_DEBUG, "s", "COLON");
#else	/*	: utMAIN	*/
	  return(shellCOLON);
#endif	/*	: utMAIN	*/
	}
 }

<USERVALUE>{

	/* string */

  (\n|\r\n) {
    BEGIN(INITIAL);
    ++shellQueryLocalCounter;
#ifdef utMAIN
    logEmit(LOG_DEBUG, "%s", "EOL");
#else	/*	: utMAIN	*/
    return(shellEOL);
#endif	/*	: utMAIN	*/
  }

  [+-]?[[:digit:]]+ {
    BEGIN(INITIAL);
    number = strtoul(yytext, (char**)0, 10);
#ifdef utMAIN
    logEmit(LOG_INFO, "NUMBER = %i", number);
#else	/*	: utMAIN	*/
    yylval->number = number;
    return(shellNUMBER);
#endif	/*	: utMAIN	*/
  }

  [^\n[:blank:]]* {
    BEGIN(INITIAL);
#ifdef utMAIN
    logEmit(LOG_INFO, "STRING = \"%s\"", yytext);
#else	/*	: utMAIN	*/
    strncpy(yylval->string, yytext, yyleng); // must-be
    yylval->string[yyleng] = (char)0;
    return(shellSTRING);
#endif	/*	: utMAIN	*/
  }
 }

<COLLECTION>{

  (\n|\r\n) {
    BEGIN(INITIAL);
    ++shellQueryLocalCounter;
#ifdef utMAIN
    logEmit(LOG_DEBUG, "%s", "EOL");
#else	/*	: utMAIN	*/
    return(shellEOL);
#endif	/*	: utMAIN	*/
  }

  [^\n[:blank:]:\-@]* {
    BEGIN(INITIAL);
#ifdef utMAIN
    logEmit(LOG_INFO, "STRING = \"%s\"", yytext);
#else	/*	: utMAIN	*/
    strncpy(yylval->string, yytext, yyleng); // must-be
    yylval->string[yyleng] = (char)0;
    return(shellSTRING);
#endif	/*	: utMAIN	*/
  }
 }

<COMMENT>{
        [^\n\r]   /* : eat up any unmatched character */

        \*\/ {
	  BEGIN(INITIAL);
	}
}

<*>{

  [[:blank:]]+  /* : eat up any blank character */

    . {  /* : eat up any unmatched character */ 

    logEmit(LOG_ERR, "exit on scanner error: %s", yytext);
    
    /* generate a parsor error (unexpected $end) */
    return -1;
  }
}

%%
   /* user code (literally copied to the generated source) :
      ==========*/


/*=======================================================================
 * Function   : getCommandLine
 * Description: scan the command line (without options)
 * Synopsis   : int getCommandLine(int argc, char** argv, int optind)
 * Input      : int argc, char** argv, int optind
 * Output     : set the commandLine global variable
 *              TRUE on success
 * Note       : remind to protect \" in cmdline
=======================================================================*/
int getCommandLine(int argc, char** argv, int optind)
{
  int rc = FALSE;
  int i = 0;
  int lenght = 0;
  char* ptr = env.commandLine;

  logEmit(LOG_DEBUG, "%s", "getCommandLine"); 
  for (i=optind; i<argc; ++i) {
    lenght = strlen(argv[i]);
    strcpy(ptr, argv[i]);
    ptr += lenght;
    *(ptr++) = ' ';
  }
  *(ptr) = (char)0;
  if (ptr == env.commandLine) goto error;
  logEmit(LOG_INFO, "command line: %s", env.commandLine);
  *(--ptr) = '\n';
  rc = TRUE;

 error:
  if (!rc) {
    logEmit(LOG_WARNING, "%s", "empty comand line");
  }
  return rc;
} 

/************************************************************************/

#ifdef utMAIN
#include "../misc/command.h"
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
GLOBAL_STRUCT_DEF;

/*=======================================================================
 * Function   : usage
 * Description: Print the usage.
 * Synopsis   : static void usage(char* programName)
 * Input      : programName = the name of the program; usually argv[0].
 * Output     : N/A
 =======================================================================*/
static void 
usage(char* programName)
{
  parserUsage(programName);
  fprintf(stderr, " query");

  parserOptions();
  fprintf(stderr, "  ---\n"
	  "  query\t\t\tTo document here...\n");
  return;
}

/*=======================================================================
 * Function   : main 
 * Author     : Nicolas ROCHE
 * modif      : 2012/05/01
 * Description: Unit test for confFile module.
 * Synopsis   : utconfFile
 * Input      : N/A
 * Output     : N/A
 =======================================================================*/
int 
main(int argc, char** argv)
{
  yyscan_t scanner;
  // ---
  int rc = 0;
  int cOption = EOF;
  char* programName = *argv;
  char* options = PARSER_SHORT_OPTIONS;
  struct option longOptions[] = {
    PARSER_LONG_OPTIONS,
    {0, 0, 0, 0}
  };

  // import mdtx environment
  getEnv(&env);

  // parse the command line
  while((cOption = getopt_long(argc, argv, options, longOptions, NULL)) 
	!= EOF) {
    switch(cOption) {

      GET_PARSER_OPTIONS; // generic options
    }
    if (rc) goto optError;
  }

  // export mdtx environment
  if (!setEnv(programName, &env)) goto optError;

  /************************************************************************/
  // !!! remind to protect \" in cmdline
  if (!getCommandLine(argc, argv, optind)) goto error;
  
  shellQuery_lex_init ( &scanner );
  shellQuery_set_debug(env.debugLexer, scanner);
  logEmit(LOG_DEBUG, "shellQuery_set_debug = %i", 
	  shellQuery_get_debug(scanner));
  
  // call scanner 
  if (shellQuery_lex(NULL, scanner)) {
    shellQuery_lex_destroy(scanner);
    goto error;
  }
  shellQuery_lex_destroy(scanner);
  /************************************************************************/

  rc = TRUE;
 error:
  ENDINGS;
  rc=!rc;
 optError:
  exit(rc);
}
 
#endif // utMAIN

/* Local Variables: */
/* mode: c */
/* mode: font-lock */
/* mode: auto-fill */
/* End: */
