@cindex Consistency

@sc{Mediatex} should ease managing server changes.

@menu
* Scenario A::          CVS conflicts.
* Scenario B::	        Address's change.
* Scenario C::	        Socket key's change.
* Scenario D::          Collection user key's change.
* Scenario E::          Host key's change.
* Scenario F::          Server's change.
@end menu

Some usual cases of typology modifications will follows.

They should induce following connectivity errors:
@itemize
@item Test @acronym{SSH} and @acronym{CVS} connectivity:
@example
$ mediatex adm update
[error message]
@end example
@item Test daemon socket's connectivity:
@example
$ mediatex srv notify 
# tail -f /var/log/mediatex.log
[error message]
@end example
@end itemize

@node Scenario A
@section CVS conflicts

@todo{}
Sorry, not documented, please refer to @sc{Cvs} (@pxref{Top,,, cvs, Concurrent Versions System}) documentation.
If you need specific permissions you can use ``@eventClientMiscSu{}'' to become the collection system user.

@node Scenario B
@section Address's change

In this section we change the @acronym{IP} on @file{/etc/network/interfaces}.

@itemize
@item If we change the @acronym{IP} address a server is currently,
we lost the socket connection from other servers.
The correction consists to update the @code{host} parameter with the new @acronym{IP} and to upgrade this host.
@example
$ vi /etc/mediatex/@var{MDTX}.conf 
<<<
host       @var{OLD_IP}
---
host       @var{NEW_IP}
>>>
$ mediatex upgrade
@end example
Other hosts will get the new address as soon as when they will upgrade too.

@item If we change @acronym{IP} on master server,
we also lost @acronym{CVS} queries from all servers.
The correction consists in the same as upper, plus re-subscribing to the collection on every slaves.
@example
slave$ mediatex adm add coll @var{MDTX}-@var{COLL}@@@var{NEW_IP}
@end example

@c To be more precise: 
@c change @code{host} parameter into @dataConfO{}'s master file and upgrade the master hosts. 
@c change @code{host} parameter into @dataServersO{} on every slaves and upgrade them.
@end itemize

@note{} By using an hostname (configured in @file{/etc/hosts} for instance)
instead of an @acronym{IP} address into @code{host} parameter from @dataConfO{}, 
changing the @acronym{IP} number has no incidence on @mediatexO{}'s configuration.

@node Scenario C
@section Socket key's change

If we change the @code{collKey} value into @dataServersO{} on one host, 
we will loose the socket connection to him and later to others until 
every hosts have upgraded. No mater we are on master or slaves.
@example
$ mediatex upgrade
@end example

@node Scenario D
@section Collection user key's change

In this section we change the collection's @acronym{SSH} keys pair.
@example
# su @var{MDTX}-@var{COLL}
$ ssh-keygen -t dsa
The key fingerprint is:
@var{NEW_FINGERPRINT}
@end example

This public key is shared and used by servers to identify themselves under the collection context. 
In fact, we re-use the @acronym{ssh} connections keys that was first dedicated to login from servers to others under the collection context (or account). 

@itemize
@item 
Changing the collection's keys on a slave server make the @acronym{cvs} connection no more available. The new keys need to be send via another media, in the same way we first connect a new server to the collection:
@example
(s1)# scp ~/@var{MDTX}-@var{COLL}/.ssh/id_dsa.pub @var{MASTER}:@var{PATH}
(s2)$ mediatex add key @var{PATH} to coll @var{COLL}
(s1)$ mediatex upgrade
@end example

@item 
On the master host you only need to update the master fingerprint into the @dataServersO{} file.
@example
$ mediatex upgrade
@end example
@end itemize

Until the new id (the fingerprint of the public key) is not known by servers 
and so they cannot match an @acronym{IP} address to a known server,
they will refuse remote incoming socket's connection.

@node Scenario E
@section Host key's change

In this section we change the host @acronym{SSH} keys pair.
@example
# ssh-keygen -f /etc/ssh/ssh_host_rsa_key
The key fingerprint is:
@var{NEWFINGERPRINT}
@end example

This public host key is shared and matched by remote servers when they connect using @acronym{ssh} to the current host.

@itemize
@item
On slave servers, upgrading is sufficient to propagate the new host's public key.
@item 
However, upgrade is not sufficient on the master host and every slaves will have to re-subscribe in order to validate its new fingerprint manually:
@example
slave$ mediatex adm add coll @var{MDTX}-@var{COLL}@@@var{MASTER}
@c or:
@c # rm ~/.ssh/known_hosts
@c # rm ~/.ssh/config 
@c $ mediatex upgrade
The authenticity of host '@var{MASTER}' can't be established.
Are you sure you want to continue connecting (yes/no)? 
@end example
@end itemize

@note{} Master host's fingerprint is written into its @dataConfO{} file or
may be obtains using:
@example
# ssh-keygen -lf /etc/ssh/ssh_host_rsa_key 
@end example

@node Scenario F
@section Server's change

In this section we move the @acronym{CVS}'s root collection's repository from master host to one other. The same procedure may also be used to backup and restore a collection on the current master host.

First we backup the collection on master host:
@example
# tar -C /var/lib/mediatex/@var{MDTX}/ @var{MDTX}-@var{COLL} -zcf backup.tgz
@end example

Next we restore it on the host we choose as new master and we re-add the collection so as to force a fresh checkout:
@example
# rm -fr /var/lib/mediatex/@var{MDTX}/@var{MDTX}-@var{COLL}
# tar -C /var/lib/mediatex/@var{MDTX}/ -zxf backup.tgz
# mediatex adm add coll @var{COLL}
@end example

@itemize
@item 
On same host (so as to restore an old state of the collection), it enough.
@item 
If we move master to a new host or one other host from the collection, all slaves will have to re-subscribe :
@example
# mediatex adm add coll @var{MDTX}-@var{COLL}@@@var{NEW-MASTER}
@end example
@end itemize

All in all, when ``upgrade'' fails we can ever re-subscribe to re-synchronise collection.
